{
  "_from": "express-validator",
  "_id": "express-validator@4.2.1",
  "_inBundle": false,
  "_integrity": "sha512-c2oiv3THmHdbDYV8qSXWq/yB17Gt3KopsseRqxKsn3s5xUz0G0E1hSQXeUjgL2+H9OAAGb6JMgc1Y9+7LO5XHg==",
  "_location": "/express-validator",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "express-validator",
    "fetchSpec": "latest",
    "name": "express-validator",
    "raw": "express-validator",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/express-validator/-/express-validator-4.2.1.tgz",
  "_shasum": "329014b2e6753bcc07cbd2c9fd3fc8cec08a0e2b",
  "_shrinkwrap": null,
  "_spec": "express-validator",
  "_where": "/home/bobobis/Documents/virtual_version",
  "author": {
    "email": "dev@tavan.de",
    "name": "Christoph Tavan"
  },
  "bugs": {
    "url": "https://github.com/ctavan/express-validator/issues"
  },
  "bundleDependencies": false,
  "contributors": [
    {
      "name": "Chris O'Hara",
      "email": "cohara87@gmail.com"
    },
    {
      "name": "@orfaust"
    },
    {
      "name": "@zero21xxx"
    },
    {
      "name": "Roman Kalyakin",
      "email": "roman@kalyakin.com"
    },
    {
      "name": "Rusty Bailey",
      "email": "rustylbailey@gmail.com"
    },
    {
      "name": "Gustavo Henke",
      "email": "guhenke@gmail.com"
    },
    {
      "name": "Ayman Nedjmeddine",
      "email": "theycallmethedr@gmail.com"
    }
  ],
  "dependencies": {
    "@types/express": "~4.0.34",
    "lodash": "^4.16.0",
    "validator": "~8.2.0"
  },
  "deprecated": false,
  "description": "Express middleware for the validator module.",
  "devDependencies": {
    "chai": "2.3.0",
    "coveralls": "2.11.14",
    "eslint": "^4.5.0",
    "express": "4.12.3",
    "mocha": "^3.5.0",
    "nyc": "^11.1.0",
    "typescript": "^2.3.4"
  },
  "engines": {
    "node": ">= 6.0.0"
  },
  "homepage": "https://github.com/ctavan/express-validator",
  "keywords": [
    "express",
    "sanitization",
    "sanitize",
    "validate",
    "validation",
    "validator",
    "xss"
  ],
  "license": "MIT",
  "main": "./index.js",
  "name": "express-validator",
  "optionalDependencies": {},
  "readme": "# express-validator\r\n\r\n[![npm version](https://img.shields.io/npm/v/express-validator.svg)](https://www.npmjs.com/package/express-validator)\r\n[![Build Status](https://img.shields.io/travis/ctavan/express-validator.svg)](http://travis-ci.org/ctavan/express-validator)\r\n[![Dependency Status](https://img.shields.io/david/ctavan/express-validator.svg)](https://david-dm.org/ctavan/express-validator)\r\n[![Coverage Status](https://img.shields.io/coveralls/ctavan/express-validator.svg)](https://coveralls.io/github/ctavan/express-validator?branch=master)\r\n\r\nAn [express.js]( https://github.com/visionmedia/express ) middleware for\r\n[validator]( https://github.com/chriso/validator.js ).\r\n\r\n- [Upgrade notice](#upgrade-notice)\r\n- [Installation](#installation)\r\n- [Usage](#usage)\r\n- [`check` API](#check-api)\r\n- [`filter` API](#filter-api)\r\n- [Sanitization Chain API](#sanitization-chain-api)\r\n- [Validation Chain API](#validation-chain-api)\r\n- [Validation Result API](#validation-result-api)\r\n- [Legacy API](#legacy-api)\r\n- [Changelog](#changelog)\r\n- [License](#license)\r\n\r\n## Upgrade notice\r\nIf you're arriving here as a express-validator v3 user after upgrading to v4, please check the [upgrade guide](UPGRADE_GUIDE.md) in order to find out what's different!\r\n\r\n## Installation\r\n```\r\nnpm install express-validator\r\n```\r\n\r\nAlso make sure that you have Node.js 6 or newer in order to use it.\r\n\r\n## Usage\r\n> The version 3 style of doing validations is still available.  \r\n> Please check the [legacy API](#legacy-api) for the docs.\r\n\r\n```javascript\r\nconst { check, validationResult } = require('express-validator/check');\r\nconst { matchedData } = require('express-validator/filter');\r\n\r\napp.post('/user', [\r\n  check('username')\r\n    // Every validator method in the validator lib is available as a\r\n    // method in the check() APIs.\r\n    // You can customize per validator messages with .withMessage()\r\n    .isEmail().withMessage('must be an email')\r\n\r\n    // Every sanitizer method in the validator lib is available as well!\r\n    .trim()\r\n    .normalizeEmail()\r\n\r\n    // ...or throw your own errors using validators created with .custom()\r\n    .custom(value => {\r\n      return findUserByEmail(value).then(user => {\r\n        throw new Error('this email is already in use');\r\n      })\r\n    }),\r\n\r\n  // General error messages can be given as a 2nd argument in the check APIs\r\n  check('password', 'passwords must be at least 5 chars long and contain one number')\r\n    .isLength({ min: 5 })\r\n    .matches(/\\d/),\r\n\r\n  // No special validation required? Just check if data exists:\r\n  check('addresses.*.street').exists(),\r\n\r\n  // Wildcards * are accepted!\r\n  check('addresses.*.postalCode').isPostalCode(),\r\n\r\n  // Sanitize the number of each address, making it arrive as an integer\r\n  sanitize('addresses.*.number').toInt()\r\n], (req, res, next) => {\r\n  // Get the validation result whenever you want; see the Validation Result API for all options!\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return res.status(422).json({ errors: errors.mapped() });\r\n  }\r\n\r\n  // matchedData returns only the subset of data validated by the middleware\r\n  const user = matchedData(req);\r\n  createUser(user).then(user => res.json(user));\r\n});\r\n```\r\n\r\n---\r\n\r\n## `check` API\r\nThese methods are all available via `require('express-validator/check')`.\r\n\r\n### `check(field[, message])`\r\n- `field`: a string or an array of strings of field names to validate against.\r\n- `message` *(optional)*: an error message to use when failed validators don't specify a message. Defaults to `Invalid value`.\r\n> *Returns:* a [Validation Chain](#validation-chain-api)\r\n\r\nCreates a validation chain for one or more fields. They may be located in any of the following request objects:\r\n- `req.body`\r\n- `req.cookies`\r\n- `req.headers`\r\n- `req.params`\r\n- `req.query`\r\n\r\nIf any of the fields are present in more than one location, then all instances of that field value must pass the validation.\r\n\r\nThe validators will always be executed serially for the same field.  \r\nThis means that if the chain targets more than one field, those will run in parallel, but each of their validators are serial.\r\n\r\n### `body(fields[, message])`\r\nSame as `check(fields[, message])`, but only checking `req.body`.\r\n\r\n### `cookie(fields[, message])`\r\nSame as `check(fields[, message])`, but only checking `req.cookies`.\r\n\r\n### `header(fields[, message])`\r\nSame as `check(fields[, message])`, but only checking `req.headers`.\r\n\r\n### `param(fields[, message])`\r\nSame as `check(fields[, message])`, but only checking `req.params`.\r\n\r\n### `query(fields[, message])`\r\nSame as `check(fields[, message])`, but only checking `req.query`.\r\n\r\n### `oneOf(validationChains[, message])`\r\n- `validationChains`: an array of [validation chains](#validation-chain-api) created with `check()` or any of its variations.\r\n- `message` *(optional)*: an error message to use when all chains failed. Defaults to `Invalid value(s)`.\r\n> *Returns:* a middleware instance\r\n\r\nCreates a middleware instance that will ensure at least one of the given chains passes the validation.  \r\nIf none of the given chains passes, an error will be pushed to the `_error` pseudo-field,\r\nusing the given `message`, and the errors of each chain will be made available under a key `nestedErrors`.\r\n\r\nExample:\r\n\r\n```js\r\nconst { check, oneOf, validationResult } = require('express-validator/check');\r\napp.post('/start-freelancing', oneOf([\r\n  check('programming_language').isIn(['javascript', 'java', 'php']),\r\n  check('design_tools').isIn(['photoshop', 'gimp'])\r\n]), (req, res, next) => {\r\n  try {\r\n    validationResult(req).throw();\r\n\r\n    // yay! we're good to start selling our skilled services :)))\r\n    res.json(...);\r\n  } catch (err) {\r\n    // Oh noes. This user doesn't have enough skills for this...\r\n    res.status(422).json(...);\r\n  }\r\n});\r\n```\r\n\r\nThe execution of those validation chains are made in parallel,\r\nwhile the execution within a chain still respects the rule defined in the [`check()` function](#checkfield-message).\r\n\r\n### `validationResult(req)`\r\n- `req`: the express request object.\r\n> *Returns:* a [validation result](#validation-result-api) object\r\n\r\nExtracts the validation errors from a request and makes it available in the form of a validation result object.\r\n\r\n---\r\n\r\n## `filter` API\r\nThese methods are all available via `require('express-validator/filter')`.\r\n\r\n### `matchedData(req[, options])`\r\n- `req`: the express request object.\r\n- `options` *(optional)*: an object of options. Defaults to `{ onlyValidData: true }`\r\n> *Returns:* an object of data validated by the `check` APIs.\r\n\r\nExtracts data validated by the `check` APIs from the request and builds\r\nan object with them. Nested paths and wildcards are properly handled as well.\r\n\r\nBy default, only valid data is included; this means if a field didn't pass\r\nits validation, it won't be included in the returned object.  \r\nYou can include invalid data by passing the option `onlyValidData` as `false`.\r\n\r\n### `sanitize(fields)`\r\n- `field`: a string or an array of strings of field names to validate against.\r\n> *Returns:* a [Sanitization Chain](#sanitization-chain-api)\r\n\r\nCreates a sanitization chain for one or more fields. They may be located in any of the following request objects:\r\n- `req.body`\r\n- `req.cookies`\r\n- `req.params`\r\n- `req.query`\r\n\r\n_* `req.headers` is **not** supported at the moment._\r\n\r\nIf any of the fields are present in more than one location, then all instances of that field value will be sanitized.\r\n\r\n### `sanitizeBody(fields)`\r\nSame as `sanitize(fields)`, but only sanitizing `req.body`.\r\n\r\n### `sanitizeCookie(fields)`\r\nSame as `sanitize(fields)`, but only sanitizing `req.cookies`.\r\n\r\n### `sanitizeParam(fields)`\r\nSame as `sanitize(fields)`, but only sanitizing `req.params`.\r\n\r\n### `sanitizeQuery(fields)`\r\nSame as `sanitize(fields)`, but only sanitizing `req.query`.\r\n\r\n---\r\n\r\n## Sanitization Chain API\r\nThe sanitization chain is a middleware, and it should be passed to an Express route handler.  \r\nWhen the middleware runs, it will modify each field in place, applying each of the sanitizers in the order they were specified:\r\n\r\n```js\r\napp.get('/', sanitizeBody('trimMe').trim(), (req, res, next) => {\r\n  // If req.body.trimMe was originally \"  something \",\r\n  // its sanitized value will be \"something\"\r\n  console.log(req.body.trimMe);\r\n});\r\n```\r\n\r\nAny of the sanitization methods listed by [validator.js](https://github.com/chriso/validator.js) are made available in all sanitization chains created by express-validator, as long as we're supporting the most up-to-date validator version.\r\n\r\n---\r\n\r\n## Validation Chain API\r\nAny of the validation and sanitization methods listed by [validator.js](https://github.com/chriso/validator.js) are made available in all validation chains created by express-validator, as long as we're supporting the most up-to-date validator version.  \r\nIf you use any of the sanitizers together with validators, the validated value is the sanitized one.\r\n\r\nAdditionally, the following methods are also available:\r\n\r\n### `.custom(validator)`\r\n- `validator(value, { req, location, path })`: the custom validator function.  \r\nReceives the value of the field being validated, as well as the express request, the location and the field path.\r\n> *Returns:* the current validation chain instance\r\n\r\nAdds a custom validator to the current validation chain.  \r\nThe custom validator may return a promise to indicate an async validation task. In case it's rejected, the field is considered invalid.\r\n\r\nThe custom validator may also throw JavaScript exceptions (eg `throw new Error()`) and return falsy values to indicate the field is invalid.\r\n\r\nExample:\r\n\r\n```js\r\napp.post('/create-user', [\r\n  check('password').exists(),\r\n  check('passwordConfirmation', 'passwordConfirmation field must have the same value as the password field')\r\n    .exists()\r\n    .custom((value, { req }) => value === req.body.password)\r\n], loginHandler);\r\n```\r\n\r\n### `.exists()`\r\n> *Returns:* the current validation chain instance\r\n\r\nAdds a validator to check for the existence of the current fields in the request.  \r\nThis means the value of the fields may not be `undefined`; any other values are acceptable.\r\n\r\n### `.not()`\r\n> *Returns:* the current validation chain instance\r\n\r\nNegates the result of the next validator.\r\n\r\n```js\r\ncheck('weekday').not().isIn(['sunday', 'saturday'])\r\n```\r\n\r\n### `.optional(options)`\r\n- `options` *(optional)*: an object of options to customize the optionality behaviour. Defaults to `{ checkFalsy: false }`.\r\n> *Returns:* the current validation chain instance\r\n\r\nMarks the current validation chain as optional.  \r\nThis is useful to remove values that are not essential to your busines and that would cause validation failures in case they were not provided in the request.\r\n\r\nBy default, this means fields with `undefined` values will be completely ignored.  \r\nHowever, if you specify the option `{ checkFalsy: true }`, then falsy values (eg `\"\"`, `0`, `false`, `null`) will also be ignored.\r\n\r\n### `.withMessage(message)`\r\n- `message`: the error message to use for the previous validator\r\n> *Returns:* the current validation chain instance\r\n\r\nSets the error message for the previous validator.  \r\nThis will have precedence over errors thrown by a custom validator.\r\n\r\n---\r\n\r\n## Validation Result API\r\nThis is an unified API for dealing with errors, both in legacy and check APIs.\r\n\r\nEach error returned by `.array()` and `.mapped()` methods have the following format by default:\r\n\r\n```js\r\n{\r\n  \"msg\": \"The error message\",\r\n  \"param\": \"param.name.with.index[0]\",\r\n  \"value\": \"param value\",\r\n  // Location of the param that generated this error.\r\n  // It's either body, query, params, cookies or headers.\r\n  \"location\": \"body\",\r\n\r\n  // nestedErrors only exist when using the oneOf function\r\n  \"nestedErrors\": [{ ... }]\r\n}\r\n```\r\n\r\n### `.isEmpty()`\r\n> *Returns:* a boolean indicating whether this result object contains no errors at all.\r\n\r\n### `.formatWith(formatter)`\r\n- `formatter(error)`: the function to use to format when returning errors.  \r\n  The `error` argument is an object in the format of `{ location, msg, param, value, nestedErrors }`, as described above.\r\n> *Returns:* this validation result instance\r\n\r\n### `.array([options])`\r\n- `options` *(optional)*: an object of options. Defaults to `{ onlyFirstError: false }`\r\n> *Returns:* an array of validation errors.\r\n\r\nGets all validation errors contained in this result object.\r\n\r\nIf the option `onlyFirstError` is set to `true`, then only the first\r\nerror for each field will be included.\r\n\r\n### `.mapped()`\r\n> *Returns:* an object where the keys are the field names, and the values are the validation errors\r\n\r\nGets the first validation error of each failed field in the form of an object.\r\n\r\n### `.throw()`\r\nIf this result object has errors, then this method will throw an exception\r\ndecorated with the same validation result API.\r\n\r\n```js\r\ntry {\r\n  validationResult(req).throw();\r\n  // Oh look at ma' success! All validations passed!\r\n} catch (err) {\r\n  console.log(err.mapped()); // Oh noes!\r\n}\r\n```\r\n\r\n---\r\n\r\n## Legacy API\r\nThe \"legacy API\" is the same API used by version 3 and older releases of express-validator.\r\n\r\nIt's based around setting a global middleware in your express app and decorating the request object with new methods.\r\n\r\n> This API **MUST NOT** be used by new apps, since it may not receive new updates and can even be removed in a future major version.\r\n\r\n### Setup\r\nYou must mount the middleware in your app before you get access to the validation/sanitization methods:\r\n\r\n```js\r\nconst expressValidator = require('express-validator');\r\napp.use(expressValidator(middlewareOptions));\r\n```\r\n\r\n### Middleware options\r\n- `errorFormatter (param, msg, value, location)`: a function that formats the error objects before returning them to your route handlers.\r\n- `customValidators`: an object where you can specify custom validators.  \r\nThe key will be the name of the validator, while the value is the validation function, receiving the value and any option.\r\n- `customSanitizers`: an object where you can specify custom sanitizers.  \r\nThe key will be the name of the sanitizer, while the value is the sanitization function, receiving the value and any option.\r\n\r\n### Legacy Validation Chain\r\nThe Legacy Validation Chain instances provides further functionality than the one provided by the base [Validation Chain](#validation-chain-api) objects.  \r\nIt also differs in that the legacy one is not a middleware *per se*.\r\n\r\nAny custom validator specified in the middleware will be made available \r\nin instances of this validation chain.\r\n\r\nAdditionally, the following validators are also available:\r\n\r\n- `.notEmpty()`: alias of `.isLength({ min: 1 })`\r\n- `.len()`: alias of `.isLength()`\r\n\r\n### `req.check(field[, message])`\r\n- `field`: the name of a single field to validate against.\r\n- `message` *(optional)*: an error message to use when failed validators don't specify a message. Defaults to `Invalid value`.\r\n> *Returns:* a [legacy validation chain](#legacy-validation-chain)\r\n\r\nCreates a validation chain for one field. It may be located in any of the following request objects:\r\n- `req.params`\r\n- `req.query`\r\n- `req.body`\r\n- `req.headers`\r\n- `req.cookies`\r\n\r\nIf it's present in more than one location, then only the first one (following the above order) will be validated against.\r\n\r\n> This function is also aliased as `req.assert()` and `req.validate()`.\r\n\r\n### `req.checkBody(field[, message])`\r\nSame as `req.check(field[, message])`, but only checking `req.body`.\r\n\r\n### `req.checkCookies(field[, message])`\r\nSame as `req.check(field[, message])`, but only checking `req.cookies`.\r\n\r\n### `req.checkHeaders(field[, message])`\r\nSame as `req.check(field[, message])`, but only checking `req.headers`.\r\n\r\n### `req.checkParams(field[, message])`\r\nSame as `req.check(field[, message])`, but only checking `req.params`.\r\n\r\n### `req.checkQuery(field[, message])`\r\nSame as `req.check(field[, message])`, but only checking `req.query`.\r\n\r\n### `req.sanitize(field)`\r\n> *Returns:* a sanitizer chain\r\n\r\nCreates a sanitizer chain that, when any of the sanitization methods is used, the return value is the sanitized value.  \r\nAlso, the parameter is sanitized in-place; that is, in the below example,\r\n`req.body.comment` will be updated to the sanitized value.\r\n\r\n```js\r\nconst comment = req.sanitize('comment').trim();\r\nconsole.log(comment === req.body.comment);\r\n```\r\n\r\nIf the sanitized parameter is present in more than one location (eg `req.query.comment` and `req.body.comment`), the will all be sanitized.\r\n\r\n> This function is also aliased as `req.filter()`.\r\n\r\n### `req.sanitizeBody(field[, message])`\r\nSame as `req.sanitize(field[, message])`, but only sanitizing `req.body`.\r\n\r\n### `req.sanitizeCookies(field[, message])`\r\nSame as `req.sanitize(field[, message])`, but only sanitizing `req.cookies`.\r\n\r\n### `req.sanitizeHeaders(field[, message])`\r\nSame as `req.sanitize(field[, message])`, but only sanitizing `req.headers`.\r\n\r\n### `req.sanitizeParams(field[, message])`\r\nSame as `req.sanitize(field[, message])`, but only sanitizing `req.params`.\r\n\r\n### `req.sanitizeQuery(field[, message])`\r\nSame as `req.sanitize(field[, message])`, but only sanitizing `req.query`.\r\n\r\n### `req.getValidationResult()`\r\n> *Returns:* a promise for a [Validation Result](#validation-result-api) object\r\n\r\nRuns all validations and returns a validation result object for the errors gathered, for both sync and async validators.\r\n\r\n### `req.asyncValidationErrors([mapped])`\r\n- `mapped` *(optional)*: whether the result must be an object instead of an array. Defaults to `false`.\r\n> *Returns:* a promise which will resolve in case all validators passed, or reject with an array of errors or an object of errors (in case `mapped` argument is `true`).\r\n\r\nRuns all validations and returns the errors gathered for all of them.\r\n\r\n### `req.validationErrors([mapped])`\r\n- `mapped` *(optional)*: whether the result must be an object instead of an array. Defaults to `false`.\r\n> *Returns:* `false` if no errors happened, an array of errors or an object of errors (in case `mapped` argument is `true`).\r\n\r\nRuns all validations and returns the errors gathered *only* for the completed validators.  \r\nThis probably means any async validator will not be completed by the time this method responds.\r\n\r\n### Schema validation\r\nAll `req.check` methods can do schema validation. This is a special way of validating data were you pass an object of your expected schema, and all the validations you want:\r\n\r\n```js\r\nreq.checkBody({\r\n  email: {\r\n    notEmpty: true,\r\n    isEmail: true\r\n  },\r\n  password: {\r\n    notEmpty: true,\r\n    matches: {\r\n      // more than one options must be passed as arrays\r\n      options: ['someregex', 'i'],\r\n      // single options may be passed directly\r\n      // options: /someregex/i\r\n    },\r\n    errorMessage: 'Invalid password'\r\n  },\r\n  // Wildcards and nested paths are supported as well\r\n  'name.first': {\r\n    optional: {\r\n      options: { checkFalsy: true }\r\n    }\r\n  },\r\n  termsAndConditionsAgreement: {\r\n    isBoolean: {\r\n      errorMessage: 'should be a boolean'\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n---\r\n\r\n## Changelog\r\n\r\nCheck the [GitHub Releases page](https://github.com/ctavan/express-validator/releases).\r\n\r\n## License\r\n\r\nMIT License\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/ctavan/express-validator.git"
  },
  "scripts": {
    "lint": "eslint lib test check filter",
    "report-coverage": "cat coverage/lcov.info | coveralls",
    "test": "nyc mocha && tsc",
    "travis-build": "npm test && npm run lint"
  },
  "types": "./index.d.ts",
  "version": "4.2.1"
}
